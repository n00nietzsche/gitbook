## 서비스 추상화

자바에는 표준 스펙, 상용 제품, 오픈 소스를 통틀어서 사용 방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다. 환경과 상황에 따라 기술이 바뀌고, 그에 따른 API를 사용하고 다른 스타일의 접근 방법을 따라야 한다는 것은 매우 피곤한 일이다.

지금까지 만든 `DAO`에 트랜잭션을 적용해보며 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 알아보자.

## 사용자 레벨 관리 기능 추가

현재 `UserDao`에서는 소위 `CRUD`라고 말하는 기능만 제공한다. 그 외에 어떠한 비즈니스 로직도 제공하지 않는다. 새로운 요구사항이 들어와서 단지 정보를 넣고 검색하는 것 외에도 정기적으로 사용자의 활동내역을 참고해서 레벨을 조정해주는 기능이 필요하다고 가정해보자.

### 요구사항

- 사용자의 `Level`은 `Basic`, `Silver`, `Gold` 중 하나다.
- 사용자가 처음 가입하면 `Basic` 레벨이 되며, 이후 활동에 따라 조건부로 한 단계씩 업그레이드 된다.
  - 가입 후 50회 이상 로그인하면 `Silver` 회원이 된다.
  - `Silver` 레벨인 상태에서 추천을 30번 이상 받으면 `Gold` 회원이 된다.
- 사용자 레벨의 변경 작업은 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족해도 레벨의 변경이 일어나지 않는다.

간단한 배치작업을 이용해 수행할 수 있다.

## 필드 추가

### Level Enum 추가

첫 요구사항을 충족하기 위해 `Level`을 만들어야 한다고 가정하자. `Level`을 저장할 때, DB에는 `varchar` 타입으로 선언하고, `"BASIC"`, `"SILVER"`, `"GOLD"`로 저장할 수도 있겠지만, 약간의 메모리라도 중요한 케이스라고 가정하고, 각 레벨을 코드화해서 숫자로 넣는다고 가정하자.

숫자로 넣기로 했다고 가정하면, `User` 객체에 추가할 프로퍼티도 `Integer` 타입의 `level` 프로퍼티를 만드는 것이 좋을까? 상수적이며 범위가 한정적인 데이터를 코드화해서 사용할 때는 `ENUM`을 이용해 구성하는 편이 좋다. 왜냐하면 단순히 `1`, `2`, `3`과 같은 코드 값을 넣으면 작성자 외에는 `1`이 어떤 `Level`을 가리키는 것인지 알 방법이 없다. 

의미가 명확하지 않은 숫자를 프로퍼티에 사용하면 타입이 안전하지 않아서 위험할 수 있다. 헷갈리기 너무 쉽다.

> 사실 `Level`을 넣을 때, 코드화한 숫자보다는 문자열 그대로 넣는 것이 좋다고 생각한다. 숫자로 넣는 경우 본의 아니게 대소관계가 생길 수 있는데 `1=BASIC` `2=SILVER` `3=GOLD`로 점점 높은 등급이 되는 명확한 대소관계가 있는 상태에서 `1.5=BRONZE`가 낄 수는 없다. 만일 `2=BRONZE`로 하고 싶다면, 이미 데이터가 많이 쌓인 상태에서 기존에 쌓였던 데이터에 대해 전부 수정을 거쳐야 한다. 기존 데이터를 건들지 않고 살짝 추가만 하고 싶다면, `4=BRONZE`와 같이 뭔가 탐탁치 않은 방식으로 해결해야 한다. 

```java
public class User {
    private static final int BASIC = 1;
    private static final int SILVER = 2;
    private static final int GOLD = 3;

    int level;

    public setLevel(int level) {
        this.level = level;
    }
    ...
```

```java
if (user1.getLevel() == User.BASIC) {
  user1.setLevel(User.SILVER);
}
```

위는 `ENUM`을 사용하지 않은 코드이다. 위와 같이 단순히 `static int`형 상수로 정의하면 `BASIC`, `SILVER`, `GOLD`와 같이 코드를 작성하여 의미있는 코드 작성은 가능하지만, 누군가 그냥 `0`, `4`, `5` 등 우리가 정의한 `Level`의 코드 범위에 속하지 않는 값을 넣으면 속수무책으로 당하고 만다. 컴파일러 단계에서 체크해줄 수 없다.

물론 `Setter`에서 `if`문을 걸어서 `BASIC`, `SILVER`, `GOLD`가 아닌 경우 `Exception`을 날리도록 할 수도 있겠지만, 런타임에서 체크를 하는 것이어서 프로그램을 실행한 이후에나 잘못 입력했는지 알 수 있을 것이다. 

정확하게 하려면 `Level`의 도메인 자체를 `ENUM` 클래스로 분리해서 관리하는 편이 훨씬 깔끔하다. `ENUM` 클래스로 분리하면 자연적으로 허가되지 않은 단순한 `int` 값은 못들어오며, 추후에 `Level`에 대한 요구사항이 확장되었을 때도 해당 도메인에 대한 코드 확장이 용이해진다.

```java
public enum Level {
    BASIC(1), SILVER(2), GOLD(3);

    private final int value;

    Level(int value) {
        this.value = value;
    }

    public int intValue() {
        return value;
    }

    public static Level valueOf(int value) {
        return switch (value) {
            case 1 -> BASIC;
            case 2 -> SILVER;
            case 3 -> GOLD;
            default -> throw new AssertionError("Unknown value: " + value);
        };
    }
}
```

`Level` 도메인에 대한 책임을 맡을 훌륭한 `ENUM` 클래스가 생성되었다. 이제 컴파일 타임에 잘못된 `int` 값이 `setLevel()`로 들어올 위험성은 줄였다.

### User 필드 추가

```java
public class User {
    ...
    Level level;
    int loginCount;
    int recommendCount;

    public Level getLevel() {
        return level;
    }
    ...
```

`ENUM` 클래스로 생성한 `Level`과 함께 로그인 회수를 카운트할 `loginCount`과 추천 회수를 카운트할 `recommendCount`도 추가했다.

> DB의 `User` 테이블에도 위 값이 담길 필드를 추가해주자.

![](https://images.velog.io/images/jakeseo_me/post/0a9b143b-3b6f-4657-8597-7bde438e6f7a/image.png)

`Postgres` 기준으로 위와 같은 타입과 이름으로 만들었다.

```java
    public User(String id, String name, String password, Level level, int loginCount, int recommendCount) {
        this.id = id;
        this.name = name;
        this.password = password;
        this.level = level;
        this.loginCount = loginCount;
        this.recommendCount = recommendCount;
    }
```

생성자도 위와 같이 새로 만들어주었다.

### UserDaoTest 수정

```java
public class UserDaoTest {
    ...
    
    @BeforeEach
    public void setUp() {
        userDao.deleteAll();
        this.user1 = new User("user1", "김똘일", "1234", Level.BASIC, 1 ,0);
        this.user2 = new User("user2", "김똘이", "1234", Level.SILVER, 55, 10);
        this.user3 = new User("user3", "김똘삼", "1234", Level.GOLD, 55, 10);
        this.user4 = new User("user4", "김똘사", "1234", Level.BASIC, 1, 0);
    }
```

기존의 픽스쳐들에도 `Level`과 `loginCount`, `recommendCount`를 추가하여 넣어주었다.

```java
private void checkSameUser(User user1, User user2) {
        assertEquals(user1.getId(), user2.getId());
        assertEquals(user1.getName(), user2.getName());
        assertEquals(user1.getPassword(), user2.getPassword());
        assertEquals(user1.getLevel(), user2.getLevel());
        assertEquals(user1.getLoginCount(), user2.getLoginCount());
        assertEquals(user1.getRecommendCount(), user2.getRecommendCount());
    }
```

![](https://images.velog.io/images/jakeseo_me/post/b8e24a3e-732a-4c05-bb79-bf254ee6f283/image.png)

바꿨으니 테스트가 잘 작동하는지 확인해보면, 2가지 테스트가 실패하는 것을 볼 수 있다. DB에 새로 생겨난 컬럼이 클래스에 잘 매핑되지 않고 있는 것 같다.

### UserDaoJdbc 수정

```java
    public UserDaoJdbc() {
        this.userRowMapper = (rs, rowNum) -> {
            User user = new User();
            user.setId(rs.getString("id"));
            user.setName(rs.getString("name"));
            user.setPassword(rs.getString("password"));
            user.setLevel(Level.valueOf(rs.getInt("level")));
            user.setLoginCount(rs.getInt("login_count"));
            user.setRecommendCount(rs.getInt("recommend_count"));
            return user;
        };
    }
```

먼저 매핑을 위와 같이 수정해준다. 이제 DB에서 데이터를 불러왔을 때 `User` 객체에는 잘 반영될 것이다.

```java
    public void add(User user) throws DuplicateUserIdException {
        try {
            this.jdbcTemplate.update("insert into users(id, name, password, level, login_count, recommend_count) values (?, ?, ?, ?, ?, ?)"
                    , user.getId()
                    , user.getName()
                    , user.getPassword()
                    , user.getLevel().intValue()
                    , user.getLoginCount()
                    , user.getRecommendCount()
            );
        } catch (DuplicateKeyException e) {
            throw new DuplicateUserIdException(e);
        }
    }
```

반대 입장에서도 자바의 `User` 객체가 DB에 잘 매핑되도록 `add()` 메소드를 잘 수정해주었다. `Level` 필드의 경우, `Level` 객체 그대로 매핑은 불가능하니 `.intValue()`라는 메소드를 이용해서 `int` 값으로 매핑해주었다.

반대로 DB에서 `User` 객체를 조회할 때는 `int` 값을 가져와서 `Level.valueOf()`를 이용해서 `Level` 객체로 다시 전환해준다. 

> 만일 이 부분에서 문자열로 작성된 SQL에 실수가 있었다면 어땠을까? 실행 전까지는 IDE내에서 어떠한 에러도 발견하지 못하고, 런타임 상태가 돼서야 `BadSqlGrammerException`이라는 예외를 날렸을 것이다.
>
> JDBC가 사용하는 SQL은 컴파일 과정에서는 자동으로 검증이 되지 않는 단순 문자열에 불과하다. 그러나, 우리는 꼼꼼하게 `UserDao`에서 생성한 모든 메소드에 대한 테스트를 작성해두었기 때문에 실제 서비스로 올라가기 전에 테스트만 돌려봤어도 해당 에러를 잡을 수 있었을 것이다.
>
> 테스트를 작성하지 않았다면, 실 서비스 실행 중에 예외가 날아다녔을 것이고, 한참 후에 수동 테스트를 통해 메세지를 보고 디버깅을 해야 그제서야 겨우 오타를 확인할 수 있었을 것이다.
>
> 그때까지 진행한 빌드와 서버 배치, 서버 재시작, 수동 테스트 등에 소모한 시간은 낭비에 가깝다. 
>
> 빠르게 실행 가능한 포괄적인 테스트를 만들어두면 이렇게 기능의 추가나 수정이 일어날 때 그 위력을 발휘한다.
