# 테스트 검증의 자동화

## 테스트 검증의 자동화

이전에 언급한 `UserDaoTest`의 두가지 문제점을 개선해보자.

- 수동 확인 작업의 번거로움 
  - 결과를 눈으로 확인해야 했다.
- 실행 작업의 번거로움 
  - 모든 클래스를 돌아다니며 `main()`을 실행해야 했다.
  
### UserDaoTest에서 검증할 것

`add()`에 전달한 `User` 오브젝트와 `get()`을 통해 가져온 `User` 오브젝트가 서로 일치하는지 확인해보자.

테스트의 결과에 대해 먼저 생각해보면, `성공`과 `실패`가 있을 것이다. 또, `실패`에는 두가지 종류가 있는데, `테스트 에러`와 `테스트 실패`이다. `테스트 에러`는 테스트 코드가 콘솔에 에러 메세지를 나타내며 에러를 내뿜을 때이고, `테스트 실패`는 테스트 코드가 콘솔에 에러 메세지를 나타내진 않지만, 테스트의 결과로 생성된 값이 생각했던 것과 다를 때이다.

`테스트 에러`는 콘솔창을 보고 단번에 알 수 있지만, `테스트 실패`는 별도의 확인작업이 있어야만 결과를 알 수 있다.

> 이전 `UserDaoTest`는 사실 결과 값이 생각했던 것과 달라 `테스트 실패`가 일어나도 정상적으로 프린트문을 출력해서 `테스트 실패`가 일어났는지 알 수 없는 테스트였다.

### UserDaoTest 코드 수정

```java
public class XmlUserDaoTest {
    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        ApplicationContext applicationContext = new GenericXmlApplicationContext("spring/applicationContext.xml");
        UserDao userDao = applicationContext.getBean(UserDao.class);

        User user = new User();
        user.setId("01");
        user.setName("제이크22522");
        user.setPassword("jakejake");

        userDao.add(user);
        User user2 = userDao.get(user.getId());

        if(!user.getName().equals(user2.getName())) {
            System.out.println("테스트 실패 (name)");
        }
        else if(!user.getPassword().equals(user2.getPassword())) {
            System.out.println("테스트 실패 (password)");
        } else {
            System.out.println("조회 테스트 성공");
        }
    }
}
```

`add()`로 `User`를 추가하고 `get()`으로 불러온 값이 일치하는지 확인해보았다.

`add()`를 통한 등록 자체는 사실 별달리 검증할 것이 없고, `테스트 에러`만 안 나면 된다. `get()`으로 `User`를 가져온 경우에는 `add()`로 등록했던 `User`와 같은 `User`인지 확인할 수 있다.

**이제 눈으로 직접 값을 비교할 필요 없이, "테스트 성공"이라는 메세지만 잘 출력되는지 확인하면 된다.**

> 켄트 백은 "테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는  것"이라고 했다.

## 테스트의 효율적인 수행과 결과 관리

`main()` 메소드를 이용한 테스트 작성 방법만으로는 결국 *실행 작업의 번거로움* 에서 벗어날 수 없다.

### JUnit 테스트로 전환하기

`JUnit`은 프레임워크이다. 프레임워크는 개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서 주도적으로 애플리케이션의 흐름을 제어한다. 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다.

`JUnit`을 이용해 테스트를 작성하면, 일일이 각 객체의 `main()`을 실행하러 다닐 필요가 없다.

### 테스트 메소드 전환

`JUnit` 프레임워크에서 테스트를 작성할 때는 조건 두가지를 따라야 한다.

1. 메소드가 `public`으로 선언되어야 한다.
2. 메소드에 `@Test`라는 애노테이션을 붙여주어야 한다.

## JUnit 코드로 전환하기

```java
public class UserDaoTest {
    @Test
    public void addAndGet() throws SQLException {
        ApplicationContext applicationContext = new GenericXmlApplicationContext("spring/applicationContext.xml");

        UserDao userDao = applicationContext.getBean(UserDao.class);

        User userToAdd = new User();
        userToAdd.setId("jinkyu1");
        userToAdd.setName("진규");
        userToAdd.setPassword("password");

        userDao.add(userToAdd);

        User userToGet = userDao.get("jinkyu1");

        Assertions.assertEquals(userToAdd.getId(), userToGet.getId());
        Assertions.assertEquals(userToAdd.getName(), userToGet.getName());
        Assertions.assertEquals(userToAdd.getPassword(), userToGet.getPassword());
    }
}
```

`JUnit5`를 이용한 코드로 전환했다.

실행도 간편하게, IDE의 도움을 받아서 TEST 전체를 실행 가능하다.

![](https://images.velog.io/images/jakeseo_me/post/5994aba6-0780-4c27-b597-2d663e57dabb/image.png)
